Вот краткий алгоритм работы шифрования DES:

### Шаги шифрования DES:

1. **Подготовка данных**:
   - Разбиваем исходное сообщение на блоки по 64 бита (8 байт). Если последний блок короче, добавляем заполнение (padding).

2. **Начальная перестановка (Initial Permutation, IP)**:
   - Каждый 64-битный блок проходит перестановку по фиксированной таблице (таблица IP), которая меняет порядок битов.

3. **Разделение на части**:
   - После перестановки блок делится на две 32-битные части: левая часть (L0) и правая часть (R0).

4. **Генерация ключей**:
   - Из 56-битного ключа (после удаления контрольных битов) генерируются 16 48-битных ключей для каждого раунда шифрования с помощью сдвигов и перестановок.

5. **16 раундов шифрования**:
   - Для каждого раунда (i) выполняются следующие операции:
     - Применяем функцию **F** к правой части (Ri-1) и ключу текущего раунда (Ki).
     - Результат функции **F** используется для операции **XOR** с левой частью (Li-1).
     - После этого меняем местами левую и правую части: новая левая часть становится старой правой (Li = Ri-1), а новая правая — результатом операции XOR (Ri = Li-1 ⊕ F(Ri-1, Ki)).

6. **Соединение L и R**:
   - После 16 раундов шифрования соединяем L16 и R16, но **без обмена местами**, в 64-битный блок.

7. **Финальная перестановка (Final Permutation, FP)**:
   - Последний шаг — применить обратную перестановку к результату, чтобы получить зашифрованные данные.

### Результат:
Каждый 64-битный блок исходных данных преобразован в 64-битный зашифрованный блок.



def des_encrypt(message, key):
    # Перевод сообщения в битовый формат
    message_bits = list(map(int, bin(int.from_bytes(message.encode(), 'big'))[2:].zfill(64)))

    # Начальная перестановка
    permuted_message = permute(message_bits, IP)

    # Разделение на левую и правую части
    L, R = permuted_message[:32], permuted_message[32:]

    # Генерация раундовых ключей
    round_keys = generate_round_keys(key)

    # 16 раундов
    for i in range(16):
        R_new = xor(L, f_function(R, round_keys[i]))
        L = R
        R = R_new

    # Соединение L и R
    final_block = R + L  # меняем местами L и R

    # Конечная перестановка
    encrypted_message = permute(final_block, FP)

    return ''.join(map(str, encrypted_message))
